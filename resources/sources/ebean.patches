Index: .classpath
===================================================================
--- .classpath	(revision 1517)
+++ .classpath	(working copy)
@@ -1,14 +1,41 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="src" output="target/classes" path="src/main/java"/>
-	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources"/>
-	<classpathentry kind="src" output="target/test-classes" path="src/test/java"/>
-	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
-	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER"/>
+	<classpathentry kind="src" output="target/classes" path="src/main/java">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
+		<attributes>
+			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
 	<classpathentry kind="src" output="target/classes" path="src/jdk_1.6/java">
 		<attributes>
 			<attribute name="optional" value="true"/>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
 		</attributes>
 	</classpathentry>
 	<classpathentry kind="output" path="target/classes"/>
Index: .settings/org.eclipse.core.resources.prefs
===================================================================
--- .settings/org.eclipse.core.resources.prefs	(revision 1517)
+++ .settings/org.eclipse.core.resources.prefs	(working copy)
@@ -1,5 +1,5 @@
-#Thu Mar 15 13:41:15 NZDT 2012
 eclipse.preferences.version=1
+encoding//src/jdk_1.6/java=UTF-8
 encoding//src/main/java=UTF-8
 encoding//src/main/resources=UTF-8
 encoding//src/test/java=UTF-8
Index: src/main/java/com/avaje/ebean/bean/EntityBeanIntercept.java
===================================================================
--- src/main/java/com/avaje/ebean/bean/EntityBeanIntercept.java	(revision 1517)
+++ src/main/java/com/avaje/ebean/bean/EntityBeanIntercept.java	(working copy)
@@ -26,6 +26,7 @@
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.net.URL;
+import java.sql.Timestamp;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -33,7 +34,9 @@
 import javax.persistence.PersistenceException;
 
 import com.avaje.ebean.Ebean;
-
+import com.avaje.ebeaninternal.server.core.DefaultServer;
+import com.avaje.ebeaninternal.server.deploy.BeanDescriptor;
+import com.avaje.ebeaninternal.server.deploy.BeanProperty;
 
 /**
  * This is the object added to every entity bean using byte code enhancement.
@@ -42,78 +45,77 @@
  * and oldValues generation for concurrency checking.
  * </p>
  */
-public final class EntityBeanIntercept implements Serializable {	
-	
-	private static final long serialVersionUID = -3664031775464862648L;
-    
-	private transient NodeUsageCollector nodeUsageCollector;
+public final class EntityBeanIntercept implements Serializable {
 
-	private transient PropertyChangeSupport pcs;
-	
-	private transient PersistenceContext persistenceContext;
-	
-	private transient BeanLoader beanLoader;
-	
-	private int beanLoaderIndex;
-	
-	private String ebeanServerName;
-	
+	private static final long				serialVersionUID	= -3664031775464862648L;
+
+	private transient NodeUsageCollector	nodeUsageCollector;
+
+	private transient PropertyChangeSupport	pcs;
+
+	private transient PersistenceContext	persistenceContext;
+
+	private transient BeanLoader			beanLoader;
+
+	private int								beanLoaderIndex;
+
+	private String							ebeanServerName;
+
 	/**
 	 * The actual entity bean that 'owns' this intercept.
 	 */
-	private EntityBean owner;
+	private EntityBean						owner;
 
 	/**
 	 * The parent bean by relationship (1-1 or 1-M).
 	 */
-	private Object parentBean;
+	private Object							parentBean;
 
 	/**
 	 * true if the bean properties have been loaded. false if it is a reference
 	 * bean (will lazy load etc).
 	 */
-	private volatile boolean loaded;
-	
+	private volatile boolean				loaded;
+
 	/**
 	 * Flag set to disable lazy loading - typically for SQL "report" type entity beans.
 	 */
-	private boolean disableLazyLoad;
-	
+	private boolean							disableLazyLoad;
+
 	/**
 	 * Flag set when lazy loading failed due to the underlying bean being deleted in the DB.
 	 */
-	private boolean lazyLoadFailure;
+	private boolean							lazyLoadFailure;
 
 	/**
 	 * Set true when loaded or reference. 
 	 * Used to bypass interception when created by user code.
 	 */
-	private boolean intercepting;
+	private boolean							intercepting;
 
 	/**
 	 * The state of the Bean (DEFAULT,UDPATE,READONLY,SHARED).
 	 */
-	private boolean readOnly;
+	private boolean							readOnly;
 
 	/**
 	 * The bean as it was before it was modified. Null if no non-transient
 	 * setters have been called.
 	 */
-	private Object oldValues;
+	private Object							oldValues;
 
 	/**
 	 * Used when a bean is partially filled.
 	 */
-	private volatile Set<String> loadedProps;
+	private volatile Set<String>			loadedProps;
 
 	/**
 	 * Set of changed properties.
 	 */
-	private HashSet<String> changedProps;
+	private HashSet<String>					changedProps;
 
-	private String lazyLoadProperty;
+	private String							lazyLoadProperty;
 
-	
 	/**
 	 * Create a intercept with a given entity.
 	 * <p>
@@ -121,35 +123,35 @@
 	 * </p>
 	 */
 	public EntityBeanIntercept(Object owner) {
-		this.owner = (EntityBean)owner;
+		this.owner = (EntityBean) owner;
 	}
-	
+
 	/**
 	 * Copy the internal state of the intercept to another intercept.
 	 */
 	public void copyStateTo(EntityBeanIntercept dest) {
 		dest.loadedProps = loadedProps;
 		dest.ebeanServerName = ebeanServerName;
-				
-		if (loaded){
+
+		if (loaded) {
 			dest.setLoaded();
 		}
 	}
-	
+
 	/**
 	 * Return the 'owning' entity bean.
 	 */
 	public EntityBean getOwner() {
 		return owner;
 	}
-	
+
 	public String toString() {
 		if (!loaded) {
 			return "Reference...";
 		}
 		return "OldValues: " + oldValues;
 	}
-	
+
 	/**
 	 * Return the persistenceContext.
 	 */
@@ -167,8 +169,8 @@
 	/**
 	 * Add a property change listener for this entity bean.
 	 */
-	public void addPropertyChangeListener(PropertyChangeListener listener){
-		if (pcs == null){
+	public void addPropertyChangeListener(PropertyChangeListener listener) {
+		if (pcs == null) {
 			pcs = new PropertyChangeSupport(owner);
 		}
 		pcs.addPropertyChangeListener(listener);
@@ -177,8 +179,8 @@
 	/**
 	 * Add a property change listener for this entity bean for a specific property.
 	 */
-	public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener){
-		if (pcs == null){
+	public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+		if (pcs == null) {
 			pcs = new PropertyChangeSupport(owner);
 		}
 		pcs.addPropertyChangeListener(propertyName, listener);
@@ -187,8 +189,8 @@
 	/**
 	 * Remove a property change listener for this entity bean.
 	 */
-	public void removePropertyChangeListener(PropertyChangeListener listener){
-		if (pcs != null){
+	public void removePropertyChangeListener(PropertyChangeListener listener) {
+		if (pcs != null) {
 			pcs.removePropertyChangeListener(listener);
 		}
 	}
@@ -196,12 +198,12 @@
 	/**
 	 * Remove a property change listener for this entity bean for a specific property.
 	 */
-	public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener){
-		if (pcs != null){
+	public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
+		if (pcs != null) {
 			pcs.removePropertyChangeListener(propertyName, listener);
 		}
 	}
-	
+
 	/**
 	 * Turn on profile collection.
 	 */
@@ -223,29 +225,29 @@
 	public void setParentBean(Object parentBean) {
 		this.parentBean = parentBean;
 	}
-	
-  /**
-   * Return the index position for batch loading via BeanLoader.
-   */
-  public int getBeanLoaderIndex() {
-    return beanLoaderIndex;
-  }
 
-  /**
-   * Set Lazy Loading by ebeanServerName.
-   * <p>
-   * This is for reference beans created by themselves.
-   * </p> 
-   */
-  public void setBeanLoaderByServerName(String ebeanServerName) {
-    this.beanLoaderIndex = 0;
-    this.beanLoader = null;
-    this.ebeanServerName = ebeanServerName;
-  }
-  
-  /**
-   * Set the BeanLoader for general lazy loading.
-   */
+	/**
+	 * Return the index position for batch loading via BeanLoader.
+	 */
+	public int getBeanLoaderIndex() {
+		return beanLoaderIndex;
+	}
+
+	/**
+	 * Set Lazy Loading by ebeanServerName.
+	 * <p>
+	 * This is for reference beans created by themselves.
+	 * </p> 
+	 */
+	public void setBeanLoaderByServerName(String ebeanServerName) {
+		this.beanLoaderIndex = 0;
+		this.beanLoader = null;
+		this.ebeanServerName = ebeanServerName;
+	}
+
+	/**
+	 * Set the BeanLoader for general lazy loading.
+	 */
 	public void setBeanLoader(int index, BeanLoader beanLoader, PersistenceContext ctx) {
 		this.beanLoaderIndex = index;
 		this.beanLoader = beanLoader;
@@ -259,7 +261,7 @@
 	 * new or dirty (and hence need saving).
 	 */
 	public boolean isDirty() {
-		if (oldValues != null){
+		if (oldValues != null) {
 			return true;
 		}
 		// need to check all the embedded beans
@@ -272,14 +274,14 @@
 	public boolean isNew() {
 		return !intercepting && !loaded;
 	}
-	
+
 	/**
 	 * Return true if the entity bean is new or dirty (and should be saved).
 	 */
 	public boolean isNewOrDirty() {
 		return isNew() || isDirty();
 	}
-	
+
 	/**
 	 * Return true if the entity is a reference.
 	 */
@@ -294,14 +296,14 @@
 		this.loaded = false;
 		this.intercepting = true;
 	}
-	
+
 	/**
 	 * Return the old values used for ConcurrencyMode.ALL.
 	 */
 	public Object getOldValues() {
 		return oldValues;
 	}
-	
+
 	/**
 	 * Return true if the bean should be treated as readOnly. If a setter method
 	 * is called when it is readOnly an Exception is thrown.
@@ -317,7 +319,7 @@
 	public void setReadOnly(boolean readOnly) {
 		this.readOnly = readOnly;
 	}
-	
+
 	/**
 	 * Return true if the bean currently has interception on.
 	 * <p>
@@ -366,38 +368,38 @@
 		this.lazyLoadProperty = null;
 		this.changedProps = null;
 	}
-	
-    /**
-     * When finished loading for lazy or refresh on an already partially
-     * populated bean.
-     */
-  public void setLoadedLazy() {
-    this.loaded = true;
-    this.intercepting = true;
-    this.lazyLoadProperty = null;
-  }
 
-  /**
-   * Mark this bean as having failed lazy loading due to the underlying row
-   * being deleted.
-   * <p>
-   * We mark the bean this way rather than immediately fail as we might be batch
-   * lazy loading and this bean might not be used by the client code at all.
-   * Instead we will fail as soon as the client code tries to use this bean.
-   * </p>
-   */
+	/**
+	 * When finished loading for lazy or refresh on an already partially
+	 * populated bean.
+	 */
+	public void setLoadedLazy() {
+		this.loaded = true;
+		this.intercepting = true;
+		this.lazyLoadProperty = null;
+	}
+
+	/**
+	 * Mark this bean as having failed lazy loading due to the underlying row
+	 * being deleted.
+	 * <p>
+	 * We mark the bean this way rather than immediately fail as we might be batch
+	 * lazy loading and this bean might not be used by the client code at all.
+	 * Instead we will fail as soon as the client code tries to use this bean.
+	 * </p>
+	 */
 	public void setLazyLoadFailure() {
-	  this.lazyLoadFailure = true;
+		this.lazyLoadFailure = true;
 	}
 
 	/**
 	 * Return true if the bean is marked as having failed lazy loading.
 	 */
 	public boolean isLazyLoadFailure() {
-    return lazyLoadFailure;
-  }
+		return lazyLoadFailure;
+	}
 
-  /**
+	/**
 	 * Return true if lazy loading is disabled.
 	 */
 	public boolean isDisableLazyLoad() {
@@ -418,31 +420,31 @@
 	 * Set the loaded status for the embedded bean.
 	 */
 	public void setEmbeddedLoaded(Object embeddedBean) {
-		if (embeddedBean instanceof EntityBean){
-			EntityBean eb = (EntityBean)embeddedBean;
+		if (embeddedBean instanceof EntityBean) {
+			EntityBean eb = (EntityBean) embeddedBean;
 			eb._ebean_getIntercept().setLoaded();
 		}
 	}
-	
+
 	/**
 	 * Return true if the embedded bean is new or dirty and hence needs saving.
 	 */
 	public boolean isEmbeddedNewOrDirty(Object embeddedBean) {
-		
-		if (embeddedBean == null){
+
+		if (embeddedBean == null) {
 			// if it was previously set then the owning bean would 
 			// have oldValues containing the previous embedded bean
 			return false;
 		}
-		if (embeddedBean instanceof EntityBean){
-			return ((EntityBean)embeddedBean)._ebean_getIntercept().isNewOrDirty();
-			
+		if (embeddedBean instanceof EntityBean) {
+			return ((EntityBean) embeddedBean)._ebean_getIntercept().isNewOrDirty();
+
 		} else {
 			// non-enhanced so must assume it is new and needs to be saved
 			return true;
 		}
 	}
-	
+
 	/**
 	 * Set the property names for a partially loaded bean.
 	 * 
@@ -459,7 +461,7 @@
 	public Set<String> getLoadedProps() {
 		return loadedProps;
 	}
-	
+
 	/**
 	 * Return the set of property names for changed properties.
 	 */
@@ -479,64 +481,64 @@
 	 */
 	protected void loadBean(String loadProperty) {
 
-    synchronized (this) {
-      if (beanLoader == null) {
-        BeanLoader serverLoader = (BeanLoader) Ebean.getServer(ebeanServerName);
-        if (serverLoader == null) {
-          throw new PersistenceException("Server ["+ebeanServerName+"] was not found?");
-        }
-        
-        // For stand alone reference bean or after deserialisation lazy load 
-        // using the ebeanServer. Synchronise only on the bean.
-        loadBeanInternal(loadProperty, serverLoader);
-        return;
-      }
-    }
-    
-    synchronized (beanLoader) {
-      // Lazy loading using LoadBeanContext which supports batch loading
-      // Synchronise on the beanLoader (a 'node' of the LoadBeanContext 'tree')
-      loadBeanInternal(loadProperty, beanLoader);
-    }
+		synchronized (this) {
+			if (beanLoader == null) {
+				BeanLoader serverLoader = (BeanLoader) Ebean.getServer(ebeanServerName);
+				if (serverLoader == null) {
+					throw new PersistenceException("Server [" + ebeanServerName + "] was not found?");
+				}
+
+				// For stand alone reference bean or after deserialisation lazy load 
+				// using the ebeanServer. Synchronise only on the bean.
+				loadBeanInternal(loadProperty, serverLoader);
+				return;
+			}
+		}
+
+		synchronized (beanLoader) {
+			// Lazy loading using LoadBeanContext which supports batch loading
+			// Synchronise on the beanLoader (a 'node' of the LoadBeanContext 'tree')
+			loadBeanInternal(loadProperty, beanLoader);
+		}
 	}
-  
+
 	/**
 	 * Invoke the lazy loading. This method is synchronised externally.
 	 */
 	private void loadBeanInternal(String loadProperty, BeanLoader loader) {
-	  
-	  if (loaded && (loadedProps == null || loadedProps.contains(loadProperty))){
-	    // race condition where multiple threads calling preGetter concurrently
-	    return;
-	  }
+
+		if (loaded && (loadedProps == null || loadedProps.contains(loadProperty))) {
+			// race condition where multiple threads calling preGetter concurrently
+			return;
+		}
 
-		if (disableLazyLoad){
+		if (disableLazyLoad) {
 			loaded = true;
 			return;
 		}
-    
+
 		if (lazyLoadFailure) {
-		  // failed when batch lazy loaded by another bean in the batch
-      throw new EntityNotFoundException("Bean has been deleted - lazy loading failed");
-    }
-    
-		if (lazyLoadProperty == null){
-		  
+			// failed when batch lazy loaded by another bean in the batch
+			throw new EntityNotFoundException("Bean has been deleted - lazy loading failed");
+		}
+
+		if (lazyLoadProperty == null) {
+
 			lazyLoadProperty = loadProperty;
-	
-			if (nodeUsageCollector != null){
+
+			if (nodeUsageCollector != null) {
 				nodeUsageCollector.setLoadProperty(lazyLoadProperty);
 			}
-	
+
 			loader.loadBean(this);
-			
-      if (lazyLoadFailure) {
-        // failed when lazy loading this bean
-        throw new EntityNotFoundException("Bean has been deleted - lazy loading failed");
-      }
-			
+
+			if (lazyLoadFailure) {
+				// failed when lazy loading this bean
+				throw new EntityNotFoundException("Bean has been deleted - lazy loading failed");
+			}
+
 			// bean should be loaded and intercepting now. setLoaded() has 
-      // been called by the lazy loading mechanism
+			// been called by the lazy loading mechanism
 		}
 	}
 
@@ -546,10 +548,10 @@
 	 * testing.
 	 */
 	protected void createOldValues() {
-		
+
 		oldValues = owner._ebean_createCopy();
-		
-		if (nodeUsageCollector != null){
+
+		if (nodeUsageCollector != null) {
 			nodeUsageCollector.setModified();
 		}
 	}
@@ -600,8 +602,8 @@
 				return false;
 			}
 
-		} 
-		if (obj1 instanceof URL){
+		}
+		if (obj1 instanceof URL) {
 			// use the string format to determine if dirty
 			return obj1.toString().equals(obj2.toString());
 		}
@@ -615,27 +617,59 @@
 	 * </p>
 	 */
 	public void preGetter(String propertyName) {
-		if (!intercepting){
+		if (!intercepting) {
 			return;
 		}
-		
+
 		if (!loaded) {
 			loadBean(propertyName);
 		} else if (loadedProps != null && !loadedProps.contains(propertyName)) {
 			loadBean(propertyName);
+		} else if (isStale()) {
+			// JBW/GW - 23OCT12: Check cache staleness.
+			loaded = false;
+			loadBean(propertyName);
 		}
 
-		if (nodeUsageCollector != null && loaded){
+		if (nodeUsageCollector != null && loaded) {
 			nodeUsageCollector.addUsed(propertyName);
 		}
 	}
 
+	// JBW/GW - 23OCT12: Check cache staleness.
+	public boolean isStale() {
+		boolean result = false;
+
+		DefaultServer loader = (DefaultServer) Ebean.getServer(ebeanServerName);
+		BeanDescriptor<?> desc = loader.getBeanDescriptor(owner.getClass());
+		//EntityBean bean = (EntityBean) owner._ebean_newInstance();
+		Object id = desc.getId(getOwner());
+		if (id != null) {
+			Object bean = desc.cacheGetBean(id, false, false);
+			//		    if (desc.loadFromCache(bean, this, id)) {
+			if (bean == null) {
+				result = false;
+			} else {
+				BeanProperty versionProp = desc.firstVersionProperty();
+				if (versionProp != null) {
+					Timestamp ownerVersionValue = (Timestamp) versionProp.getValue(owner);
+					Timestamp cacheVersionValue = (Timestamp) versionProp.getValue(bean);
+					if ((ownerVersionValue != null) && (cacheVersionValue != null)) {
+						result = (ownerVersionValue.before(cacheVersionValue));
+					}
+				}
+			}
+		}
+
+		return result;
+	}
+
 	/**
 	 * Called for "enhancement" postSetter processing.
 	 * This is around a PUTFIELD so no need to check the newValue afterwards.
 	 */
-	public void postSetter(PropertyChangeEvent event){
-		if (pcs != null && event != null){
+	public void postSetter(PropertyChangeEvent event) {
+		if (pcs != null && event != null) {
 			pcs.firePropertyChange(event);
 		}
 	}
@@ -645,9 +679,9 @@
 	 * Here the newValue has to be re-fetched (and passed into this method)
 	 * in case there is code inside the setter that further mutates the value.
 	 */
-	public void postSetter(PropertyChangeEvent event, Object newValue){
-		if (pcs != null && event != null){
-			if (newValue != null && newValue.equals(event.getNewValue())){
+	public void postSetter(PropertyChangeEvent event, Object newValue) {
+		if (pcs != null && event != null) {
+			if (newValue != null && newValue.equals(event.getNewValue())) {
 				pcs.firePropertyChange(event);
 			} else {
 				pcs.firePropertyChange(event.getPropertyName(), event.getOldValue(), newValue);
@@ -655,271 +689,266 @@
 		}
 	}
 
-	
-
-
 	/**
 	 * OneToMany and ManyToMany don't have any interception so just check for PropertyChangeSupport.
 	 */
 	public PropertyChangeEvent preSetterMany(boolean interceptField, String propertyName, Object oldValue, Object newValue) {
-				
+
 		// skip setter interception on many's
-		if (pcs != null){
+		if (pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, oldValue, newValue);
 		} else {
 			return null;
-		}		
+		}
 	}
-	
+
 	private final void addDirty(String propertyName) {
-		
-		if (!intercepting){
+
+		if (!intercepting) {
 			return;
 		}
 		if (readOnly) {
 			throw new IllegalStateException("This bean is readOnly");
 		}
-		
+
 		if (loaded) {
-			if (oldValues == null){
+			if (oldValues == null) {
 				// first time this bean is being made dirty
 				createOldValues();
 			}
-			if (changedProps == null){
+			if (changedProps == null) {
 				changedProps = new HashSet<String>();
 			}
-			changedProps.add(propertyName);						
+			changedProps.add(propertyName);
 		}
 	}
-	
+
 	/**
 	 * Check to see if the values are not equal. If they are not equal then
 	 * create the old values for use with ConcurrencyMode.ALL.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, Object oldValue, Object newValue) {
-		
+
 		boolean changed = !areEqual(oldValue, newValue);
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, oldValue, newValue);
 		}
-		
-		return null; 
+
+		return null;
 	}
 
 	/**
 	 * Check for primitive boolean.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, boolean oldValue, boolean newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
 
-		if (changed && pcs != null){
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Boolean.valueOf(oldValue), Boolean.valueOf(newValue));
 		}
-		
-		return null; 
+
+		return null;
 	}
-	
+
 	/**
 	 * Check for primitive int.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, int oldValue, int newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Integer.valueOf(oldValue), Integer.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * long.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, long oldValue, long newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Long.valueOf(oldValue), Long.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * double.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, double oldValue, double newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Double.valueOf(oldValue), Double.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * float.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, float oldValue, float newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Float.valueOf(oldValue), Float.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * short.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, short oldValue, short newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Short.valueOf(oldValue), Short.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * char.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, char oldValue, char newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Character.valueOf(oldValue), Character.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * char.
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, byte oldValue, byte newValue) {
-		
+
 		boolean changed = oldValue != newValue;
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, Byte.valueOf(oldValue), Byte.valueOf(newValue));
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * char[].
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, char[] oldValue, char[] newValue) {
-		
+
 		boolean changed = !areEqualChars(oldValue, newValue);
 
-		if (intercept && changed){
+		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, oldValue, newValue);
 		}
-		return null; 
+		return null;
 	}
 
 	/**
 	 * byte[].
 	 */
 	public PropertyChangeEvent preSetter(boolean intercept, String propertyName, byte[] oldValue, byte[] newValue) {
-		
+
 		boolean changed = !areEqualBytes(oldValue, newValue);
 
 		if (intercept && changed) {
 			addDirty(propertyName);
 		}
-		
-		if (changed && pcs != null){
+
+		if (changed && pcs != null) {
 			return new PropertyChangeEvent(owner, propertyName, oldValue, newValue);
 		}
-		return null; 
+		return null;
 	}
-	
 
-	
 	private static boolean areEqualBytes(byte[] b1, byte[] b2) {
 		if (b1 == null) {
 			return (b2 == null);
-		
+
 		} else if (b2 == null) {
 			return false;
-			
+
 		} else if (b1 == b2) {
 			return true;
-		
-		} else if (b1.length != b2.length){
+
+		} else if (b1.length != b2.length) {
 			return false;
 		}
 		for (int i = 0; i < b1.length; i++) {
-			if (b1[i] != b2[i]){
+			if (b1[i] != b2[i]) {
 				return false;
 			}
 		}
 		return true;
 	}
-	
+
 	private static boolean areEqualChars(char[] b1, char[] b2) {
 		if (b1 == null) {
 			return (b2 == null);
-		
+
 		} else if (b2 == null) {
 			return false;
-			
+
 		} else if (b1 == b2) {
 			return true;
-		
-		} else if (b1.length != b2.length){
+
+		} else if (b1.length != b2.length) {
 			return false;
 		}
 		for (int i = 0; i < b1.length; i++) {
-			if (b1[i] != b2[i]){
+			if (b1[i] != b2[i]) {
 				return false;
 			}
 		}
Index: src/main/java/com/avaje/ebeaninternal/server/cache/CachedBeanDataToBean.java
===================================================================
--- src/main/java/com/avaje/ebeaninternal/server/cache/CachedBeanDataToBean.java	(revision 1517)
+++ src/main/java/com/avaje/ebeaninternal/server/cache/CachedBeanDataToBean.java	(working copy)
@@ -1,5 +1,6 @@
 package com.avaje.ebeaninternal.server.cache;
 
+import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -11,107 +12,110 @@
 
 public class CachedBeanDataToBean {
 
-    private final BeanDescriptor<?> desc;
-    private final Object bean;
-    private final EntityBeanIntercept ebi;
-    private final CachedBeanData cacheBeandata;
-    private final Set<String> cacheLoadedProperties;
-    private final Set<String> loadedProps;
-    
-    private final Set<String> excludeProps;
-    private final Object oldValuesBean;
-    private final boolean readOnly;
+	private final BeanDescriptor<?>		desc;
+	private final Object				bean;
+	private final EntityBeanIntercept	ebi;
+	private final CachedBeanData		cacheBeandata;
+	private final Set<String>			cacheLoadedProperties;
+	private final Set<String>			loadedProps;
+
+	private final Set<String>			excludeProps;
+	private final Object				oldValuesBean;
+	private final boolean				readOnly;
+
+	public static void load(BeanDescriptor<?> desc, Object bean, CachedBeanData cacheBeandata) {
+		if (bean instanceof EntityBean) {
+			load(desc, bean, ((EntityBean) bean)._ebean_getIntercept(), cacheBeandata);
+		} else {
+			load(desc, bean, null, cacheBeandata);
+		}
+	}
+
+	public static void load(BeanDescriptor<?> desc, Object bean, EntityBeanIntercept ebi, CachedBeanData cacheBeandata) {
+		new CachedBeanDataToBean(desc, bean, ebi, cacheBeandata).load();
+	}
+
+	private CachedBeanDataToBean(BeanDescriptor<?> desc, Object bean, EntityBeanIntercept ebi, CachedBeanData cacheBeandata) {
+		this.desc = desc;
+		this.bean = bean;
+		this.ebi = ebi;
+		this.cacheBeandata = cacheBeandata;
+		this.cacheLoadedProperties = cacheBeandata.getLoadedProperties();
+		this.loadedProps = (cacheLoadedProperties == null) ? null : new HashSet<String>();
+
+		if (ebi != null) {
+			this.excludeProps = ebi.getLoadedProps();
+			this.oldValuesBean = ebi.getOldValues();
+			this.readOnly = ebi.isReadOnly();
+		} else {
+			this.excludeProps = null;
+			this.oldValuesBean = null;
+			this.readOnly = false;
+		}
+	}
 
-    public static void load(BeanDescriptor<?> desc, Object bean, CachedBeanData cacheBeandata) {
-    	if (bean instanceof EntityBean){
-    	    load(desc, bean, ((EntityBean)bean)._ebean_getIntercept(), cacheBeandata);
-    	} else {
-    	    load(desc, bean, null, cacheBeandata);
-    	}
-    }
+	private boolean load() {
 
-    public static void load(BeanDescriptor<?> desc, Object bean, EntityBeanIntercept ebi, CachedBeanData cacheBeandata) {
-    	new CachedBeanDataToBean(desc, bean, ebi, cacheBeandata).load();
-    }
-    
-    private CachedBeanDataToBean(BeanDescriptor<?> desc, Object bean, EntityBeanIntercept ebi, CachedBeanData cacheBeandata) {
-        this.desc = desc;
-        this.bean = bean;
-        this.ebi = ebi;
-        this.cacheBeandata = cacheBeandata;
-        this.cacheLoadedProperties = cacheBeandata.getLoadedProperties();
-        this.loadedProps = (cacheLoadedProperties == null) ? null : new HashSet<String>();
-       
-        if (ebi != null){
-        	this.excludeProps = ebi.getLoadedProps(); 
-        	this.oldValuesBean = ebi.getOldValues();
-        	this.readOnly = ebi.isReadOnly();
-        } else {
-        	this.excludeProps = null;
-        	this.oldValuesBean = null;
-        	this.readOnly = false;
-        }
-    }
-    
-    private boolean load(){
-        
-        BeanProperty[] propertiesNonTransient = desc.propertiesNonMany();
-        for (int i = 0; i < propertiesNonTransient.length; i++) {
-            BeanProperty prop = propertiesNonTransient[i];
-            if (includeNonManyProperty(prop.getName())){
-            	Object data = cacheBeandata.getData(i);
-                prop.setCacheDataValue(bean, data, oldValuesBean, readOnly);
-            }
-        }
-        BeanPropertyAssocMany<?>[] manys = desc.propertiesMany();
+		BeanProperty[] propertiesNonTransient = desc.propertiesNonMany();
+		for (int i = 0; i < propertiesNonTransient.length; i++) {
+			BeanProperty prop = propertiesNonTransient[i];
+			if (includeNonManyProperty(prop.getName())) {
+				// JBW/GW - 23OCT12: There are legitimate cases where the parent class ref is abstract.
+				if (!Modifier.isAbstract(prop.getPropertyType().getModifiers())) {
+					Object data = cacheBeandata.getData(i);
+					prop.setCacheDataValue(bean, data, oldValuesBean, readOnly);
+				}
+			}
+		}
+		BeanPropertyAssocMany<?>[] manys = desc.propertiesMany();
 		for (int i = 0; i < manys.length; i++) {
 			BeanPropertyAssocMany<?> prop = manys[i];
-			if (includeManyProperty(prop.getName())){
+			if (includeManyProperty(prop.getName())) {
 				// set a lazy loading proxy
-				prop.createReference(bean);				
+				prop.createReference(bean);
+			}
+		}
+
+		if (ebi != null) {
+			if (loadedProps == null) {
+				ebi.setLoadedProps(null);
+			} else {
+				HashSet<String> mergeProps = new HashSet<String>();
+				if (excludeProps != null) {
+					mergeProps.addAll(excludeProps);
+				}
+				mergeProps.addAll(loadedProps);
+				ebi.setLoadedProps(mergeProps);
 			}
+			ebi.setLoadedLazy();
+		}
+
+		return true;
+	}
+
+	private boolean includeManyProperty(String name) {
+		if (excludeProps != null && excludeProps.contains(name)) {
+			// ignore this property (partial bean lazy loading)
+			return false;
+		}
+		if (loadedProps != null) {
+			loadedProps.add(name);
 		}
-        
-        if (ebi != null){
-        	if (loadedProps == null){
-            	ebi.setLoadedProps(null);
-        	} else {
-            	HashSet<String> mergeProps = new HashSet<String>();
-            	if (excludeProps != null) {
-            		mergeProps.addAll(excludeProps);
-            	}
-        		mergeProps.addAll(loadedProps);
-            	ebi.setLoadedProps(mergeProps);
-        	}   
-        	ebi.setLoadedLazy();
-        }
+		return true;
+	}
 
-        return true;
-    }
-    
-    private boolean includeManyProperty(String name) {
-        if (excludeProps != null && excludeProps.contains(name)){
-            // ignore this property (partial bean lazy loading)
-            return false;
-        }
-        if (loadedProps != null){
-            loadedProps.add(name);
-        }
-        return true;
-    }
-    
-    private boolean includeNonManyProperty(String name) {
-        if (excludeProps != null && excludeProps.contains(name)){
-            // ignore this property (partial bean lazy loading)
-            return false;
-        }
-        if (cacheLoadedProperties != null && !cacheLoadedProperties.contains(name)){
-            return false;
-        }
-        if (loadedProps != null){
-            loadedProps.add(name);
-        }
-        return true;
-    }
-    
+	private boolean includeNonManyProperty(String name) {
+		if (excludeProps != null && excludeProps.contains(name)) {
+			// ignore this property (partial bean lazy loading)
+			return false;
+		}
+		if (cacheLoadedProperties != null && !cacheLoadedProperties.contains(name)) {
+			return false;
+		}
+		if (loadedProps != null) {
+			loadedProps.add(name);
+		}
+		return true;
+	}
+
 }
\ No newline at end of file
Index: src/main/java/com/avaje/ebeaninternal/server/deploy/BeanDescriptor.java
===================================================================
--- src/main/java/com/avaje/ebeaninternal/server/deploy/BeanDescriptor.java	(revision 1517)
+++ src/main/java/com/avaje/ebeaninternal/server/deploy/BeanDescriptor.java	(working copy)
@@ -1176,6 +1176,18 @@
     for (int i = 0; i < propertiesOneImported.length; i++) {
       propertiesOneImported[i].cacheDelete(false, insertRequest.getBean());
     }
+	    
+    // JBW/GW - 23OCT12: Cache not getting updated?
+	  Object bean = insertRequest.getBean();
+	  CachedBeanData beanData = CachedBeanDataFromBean.extract(this, bean);
+
+	    getBeanCache().put(id, beanData);
+	    if (beanData.isNaturalKeyUpdate() && naturalKeyCache != null) {
+	      Object naturalKey = beanData.getNaturalKey();
+	      if (naturalKey != null) {
+	        naturalKeyCache.put(naturalKey, id);
+	      }
+	    }
   }
 
   /**
Index: src/main/java/com/avaje/ebeaninternal/server/deploy/DetermineManyType.java
===================================================================
--- src/main/java/com/avaje/ebeaninternal/server/deploy/DetermineManyType.java	(revision 1517)
+++ src/main/java/com/avaje/ebeaninternal/server/deploy/DetermineManyType.java	(working copy)
@@ -38,13 +38,16 @@
     }
     
 	public ManyType getManyType(Class<?> type) {
-        if (type.equals(List.class)){
+        // JBW/GW - 23OCT12: allow sub classes of List
+        if (List.class.isAssignableFrom(type)){
         	return ManyType.JAVA_LIST;
         }
-        if (type.equals(Set.class)){
+        // JBW/GW - 23OCT12: allow sub classes of Set
+        if (Set.class.isAssignableFrom(type)){
         	return ManyType.JAVA_SET;
-        } 
-        if (type.equals(Map.class)){
+        }
+        // JBW/GW - 23OCT12: allow sub classes of Map
+        if (Map.class.isAssignableFrom(type)){
         	return ManyType.JAVA_MAP;
         }
         if (withScalaSupport){
Index: src/main/java/com/avaje/ebeaninternal/server/deploy/ReflectGetter.java
===================================================================
--- src/main/java/com/avaje/ebeaninternal/server/deploy/ReflectGetter.java	(revision 1517)
+++ src/main/java/com/avaje/ebeaninternal/server/deploy/ReflectGetter.java	(working copy)
@@ -39,66 +39,71 @@
 	 * id from abstract inheritance hierarchy object.
 	 */
 	public static BeanReflectGetter create(DeployBeanProperty prop) {
-			
-		if (!prop.isId()){
-			// not expecting this to ever be used/called
-			return new NonIdGetter(prop.getFullBeanName());
-			
+
+		// JBW/GW - 28OCT12: A better way to check abstract class properties.
+		String property = prop.getFullBeanName();
+		Method readMethod = prop.getReadMethod();
+		if (!prop.isId()) {
+			if (readMethod == null) {
+				// not expecting this to ever be used/called
+				return new NonIdGetter(prop.getFullBeanName());
+			} else {
+				// But there is a read method, so use it.
+				return new IdGetter(property, readMethod);
+			}
+
 		} else {
-			String property = prop.getFullBeanName();
-			Method readMethod = prop.getReadMethod();
-			if (readMethod == null){
-				String m = "Abstract class with no readMethod for "+property;
+			if (readMethod == null) {
+				String m = "Abstract class with no readMethod for " + property;
 				throw new RuntimeException(m);
 			}
 			return new IdGetter(property, readMethod);
-		} 
+		}
 	}
-	
+
 	public static class IdGetter implements BeanReflectGetter {
 
-		public static final Object[] NO_ARGS = new Object[0];
-		
-		private final Method readMethod;
-		private final String property;
-		
+		public static final Object[]	NO_ARGS	= new Object[0];
+
+		private final Method			readMethod;
+		private final String			property;
+
 		public IdGetter(String property, Method readMethod) {
 			this.property = property;
 			this.readMethod = readMethod;
 		}
-		
+
 		public Object get(Object bean) {
 			try {
 				return readMethod.invoke(bean, NO_ARGS);
 			} catch (Exception e) {
-				String m = "Error on ["+property+"] using readMethod "+readMethod;
+				String m = "Error on [" + property + "] using readMethod " + readMethod;
 				throw new RuntimeException(m, e);
-			} 
+			}
 		}
-	
+
 		public Object getIntercept(Object bean) {
 			return get(bean);
 		}
 	}
 
 	public static class NonIdGetter implements BeanReflectGetter {
-		
-		private final String property;
-		
+
+		private final String	property;
+
 		public NonIdGetter(String property) {
 			this.property = property;
 		}
-		
+
 		public Object get(Object bean) {
-			
-			String m = "Not expecting this method to be called on ["+property
-				+"] as it is a NON ID property on an abstract class";
-			throw new RuntimeException(m); 
+
+			String m = "Not expecting this method to be called on [" + property + "] as it is a NON ID property on an abstract class";
+			throw new RuntimeException(m);
 		}
 
 		public Object getIntercept(Object bean) {
 			return get(bean);
 		}
 	}
-	
+
 }
Index: src/test/java/com/avaje/tests/batchload/TestManyAfterCacheUpdate.java
===================================================================
--- src/test/java/com/avaje/tests/batchload/TestManyAfterCacheUpdate.java	(revision 0)
+++ src/test/java/com/avaje/tests/batchload/TestManyAfterCacheUpdate.java	(revision 0)
@@ -0,0 +1,121 @@
+package com.avaje.tests.batchload;
+
+import java.util.List;
+
+import junit.framework.TestCase;
+
+import org.junit.Assert;
+
+import com.avaje.ebean.BeanState;
+import com.avaje.ebean.Ebean;
+import com.avaje.ebean.cache.ServerCacheManager;
+import com.avaje.tests.model.basic.Contact;
+import com.avaje.tests.model.basic.Customer;
+import com.avaje.tests.model.basic.ResetBasicData;
+
+public class TestManyAfterCacheUpdate extends TestCase {
+
+    public void test() {
+        
+        ResetBasicData.reset();
+        ServerCacheManager serverCacheManager = Ebean.getServerCacheManager();
+        serverCacheManager.clearAll();
+        
+        // Select two beans of the same customer (both should reference the same cache item).
+        List<Customer> custs = Ebean.find(Customer.class).findList();
+        Integer customerId = custs.get(0).getId();
+        
+        Customer customer1 = Ebean.find(Customer.class)
+                .setId(customerId)
+                .select("name")
+                .findUnique();
+            
+        Customer customer2 = Ebean.find(Customer.class)
+                .setId(customerId)
+                .select("name")
+                .findUnique();
+            
+        // Verify that both beans are clean.
+        BeanState beanState1 = Ebean.getBeanState(customer1);
+        Assert.assertFalse(beanState1.isNew());
+        Assert.assertFalse(beanState1.isDirty());
+        Assert.assertFalse(beanState1.isNewOrDirty());
+        Assert.assertNotNull(beanState1.getLoadedProps());
+        
+        BeanState beanState2 = Ebean.getBeanState(customer2);
+        Assert.assertFalse(beanState2.isNew());
+        Assert.assertFalse(beanState2.isDirty());
+        Assert.assertFalse(beanState2.isNewOrDirty());
+        Assert.assertNotNull(beanState2.getLoadedProps());
+        
+        // Verify the contacts count for both references to the bean.
+        Assert.assertEquals(3, customer1.getContacts().size());
+        Assert.assertEquals(3, customer2.getContacts().size());
+        
+        // Create a new contact and add it to the bean using one of the references.
+        Contact newContact = new Contact();
+        newContact.setCustomer(customer1);
+        newContact.setFirstName("first1");
+        newContact.setLastName("last1");
+        customer1.addContact(newContact);
+        Ebean.save(newContact);
+        
+        // Now reselect the bean into the two references (both should refer to the same cache item).
+        customer1 = Ebean.find(Customer.class)
+                .setId(customerId)
+                .select("name")
+                .findUnique();
+            
+        customer2 = Ebean.find(Customer.class)
+                .setId(customerId)
+                .select("name")
+                .findUnique();
+            
+        // Verify that both beans are clean.
+        beanState1 = Ebean.getBeanState(customer1);
+        Assert.assertFalse(beanState1.isNew());
+        Assert.assertFalse(beanState1.isDirty());
+        Assert.assertFalse(beanState1.isNewOrDirty());
+        Assert.assertNotNull(beanState1.getLoadedProps());
+        
+        beanState2 = Ebean.getBeanState(customer2);
+        Assert.assertFalse(beanState2.isNew());
+        Assert.assertFalse(beanState2.isDirty());
+        Assert.assertFalse(beanState2.isNewOrDirty());
+        Assert.assertNotNull(beanState2.getLoadedProps());
+        
+        // THIS IS THE FIRST PART THAT IS THE KEY TO WHAT I DON"T UNDERSTAND.
+        // AT THIS POINT BOTH BEANS SEE THAT THEY NEED TO LAZY LOAD THE CONTACTS REFERENCE.
+        // ESSENTIALLY IT SEES THE GRAPH IS NOT FRESH OR UP-TO-DATE.
+        Assert.assertEquals(4, customer1.getContacts().size());
+        Assert.assertEquals(4, customer2.getContacts().size());
+
+        // Now create a new contact for the bean using one of the bean references.
+        Contact newContact2 = new Contact();
+        newContact2.setCustomer(customer1);
+        newContact2.setFirstName("first2");
+        newContact2.setLastName("last2");
+        customer1.addContact(newContact2);
+        Ebean.save(newContact2);
+        
+        // THIS IS THE OTHER PART THAT IS KEY TO WHAT I DON'T UNDERSTAND.
+        // WHEN EBEAN CREATES THE GRAPH FROM LAZY LOAD, IT KNOWS THE CONTACTS REFERENCE IS NOT FRESH.
+        // BUT ON SECOND USAGE (WHEN THE BEAN IS DIRTY) IT NO LONGER HAS ANY EFFECT.  
+        // YOU HAVE STALE DATA, BUT NO POSSIBLE WAY TO SEE THIS FROM THE OBJECT GRAPH.     
+        Assert.assertEquals(5, customer1.getContacts().size());
+        Assert.assertEquals(5, customer2.getContacts().size());
+
+        // My assertion is the first time you access a property you get something from the cache and you know it's fresh.
+        // ANy subsequent time you access a property Ebean only checks the "loaded" property.  If it's dirty in the cache there is no way to know.
+        // In-memory bean references are essentially cutoff from the cache once loaded.
+        
+        // This might be OK for POST/GET web-pages where every page-load happens from bean IDs.
+        // For SPA webapps and desktop apps that hold onto bean references for a long time, there is no way to know if the bean 
+        // reference is stale or not.  It seems you cannot use/trust the object graph at all in these cases.
+        
+        // Is there be a model for Ebean that goes beyond "get a bean graph/ref, use it, then throw it away?"
+        
+        // Maybe I just don't understand what to do in these cases.
+        
+    }
+}
